{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction What is Canopie? Canopie is a Super App engine that consists of a collection of APIs, SDKs, tools and relevant software that enable the creation of an entire ecosystem/marketplace. Canopie services can be deployed on premise or to public cloud. Services provide RESTful APIs and can be white labelled on the UI. This is to help accelerate third party development and bring value to the platform instead of dealing with the plumbing and building an entire marketplace from scratch. What is a Super App? A Super App is a mobile application that has the ability to run other apps inside them. These \"Mini Apps\" are discreet functionality that are created independently by other developers of the same company or even external third parties to achieve better scalability. You can think of the main host app as a shopping mall. The mall leases out space to other shops. These are the Mini Apps. They each have their own independent business models and provide goods and services to the people coming into the shopping mall. The shopping mall provides people, security, parking and common utilities so that the shops can focus on providing value to the customer. Technically, Super Apps are mobile applications on either iOS or Android that have their own marketplace or \"Mini Apps\" inside them. Mini Apps are usually served through a webview and have a specialized subset of HTML and Javascript as its own Domain specific language (DSL). Mini Apps have their own load and unload life cycles and provide extra value to the end user by leveraging the assets of the host Super App. For a developer perspective on building Mini Apps, read on. For enterprise customers, head to the enterprise section for more details. General Flow Let's break this down step by step. Creating the Invite Code and Sending it to Developers (Steps 1 and 2) Organizations want to manage invitation campaigns and potentially limit the number of sign ups to the platform. Especially when they are deploying a new ecosystem like Canopie. Canopie gives organizations the ability to track and manage the number of developers signing up via a unique, human readable invitation code. This also gives developers that already have an account with Canopie be able to join more than one organization that use Canopie also. This process is more streamlined and you don't need to create multiple developer accounts. The first two steps provide this capability. As a developer, if you're wondering if you could deploy your Mini App across more than one organization's Super App, your guess is correct! Just make sure that you cater for custom SDK calls if each ecosystem has a custom SDK. More on that later. Registering and Creating Mini Apps (Steps 3 and 4) Developers, whether they are individuals or organizations need to register on Canopie. Organizations need to know who you are and verify your identity to ensure that they know who they're talking to and can help you through the process if your app gets rejected due to a guideline issue. Make sure to provide the correct invitation code so that you get associated with the organization. Using Canopie markup and JavaScript , you can create Mini Apps. Canopie comes pre-loaded with an SDK and Material UI style so that you don't need to build anything from scratch. Example Canopie Code CPML {{ items.map((item, idx) => cpml` < list-item id = 'item-{{idx}}' > < view class = 'content' > < text class = 'primary-content' > {{item.name}}, {{item.price}} </ text > </ view > </ list-item > `) }} JavaScript Page ({ data : { items : [ { name : 'Apple' , price : 1.50 }, { name : 'Durian' , price : 40.00 } ] } }); This example code loops through the items list and renders a <text> element for each item based on the template. On the JavaScript side, the data is pre-loaded for the Page that will be loaded for the Mini App. It pre-populates the items variable with a json structure. This terminology, examples of Canopie markup and JavaScript will be further explained in the next sections. On the Developer portal itself, you need to \"create\" the Mini App and fill in its details. You'll then get a link to Note: Canopie is currently in Alpha and not yet making these tools public. A Visual Studio Code plug-in is also coming soon. Submitting and Publishing (Steps 5 to 8) When you're done and happy with the Mini App. Hop onto the Developer Portal to see your builds. Submit one of those builds to get it reviewed. The reviewer in the organization will take a look, launch, test and read the description of your Mini App. They need to ensure that your Mini App follows their organization guidelines and that it provides good value to the end user. If everything is good, the reviewer accepts the submission and you then have the option of publishing it into production. The Mini Apps get deployed to a CDN and produce a QR code for users on the Super App to scan and launch.","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#what-is-canopie","text":"Canopie is a Super App engine that consists of a collection of APIs, SDKs, tools and relevant software that enable the creation of an entire ecosystem/marketplace. Canopie services can be deployed on premise or to public cloud. Services provide RESTful APIs and can be white labelled on the UI. This is to help accelerate third party development and bring value to the platform instead of dealing with the plumbing and building an entire marketplace from scratch.","title":"What is Canopie?"},{"location":"#what-is-a-super-app","text":"A Super App is a mobile application that has the ability to run other apps inside them. These \"Mini Apps\" are discreet functionality that are created independently by other developers of the same company or even external third parties to achieve better scalability. You can think of the main host app as a shopping mall. The mall leases out space to other shops. These are the Mini Apps. They each have their own independent business models and provide goods and services to the people coming into the shopping mall. The shopping mall provides people, security, parking and common utilities so that the shops can focus on providing value to the customer. Technically, Super Apps are mobile applications on either iOS or Android that have their own marketplace or \"Mini Apps\" inside them. Mini Apps are usually served through a webview and have a specialized subset of HTML and Javascript as its own Domain specific language (DSL). Mini Apps have their own load and unload life cycles and provide extra value to the end user by leveraging the assets of the host Super App. For a developer perspective on building Mini Apps, read on. For enterprise customers, head to the enterprise section for more details.","title":"What is a Super App?"},{"location":"#general-flow","text":"Let's break this down step by step.","title":"General Flow"},{"location":"#creating-the-invite-code-and-sending-it-to-developers-steps-1-and-2","text":"Organizations want to manage invitation campaigns and potentially limit the number of sign ups to the platform. Especially when they are deploying a new ecosystem like Canopie. Canopie gives organizations the ability to track and manage the number of developers signing up via a unique, human readable invitation code. This also gives developers that already have an account with Canopie be able to join more than one organization that use Canopie also. This process is more streamlined and you don't need to create multiple developer accounts. The first two steps provide this capability. As a developer, if you're wondering if you could deploy your Mini App across more than one organization's Super App, your guess is correct! Just make sure that you cater for custom SDK calls if each ecosystem has a custom SDK. More on that later.","title":"Creating the Invite Code and Sending it to Developers (Steps 1 and 2)"},{"location":"#registering-and-creating-mini-apps-steps-3-and-4","text":"Developers, whether they are individuals or organizations need to register on Canopie. Organizations need to know who you are and verify your identity to ensure that they know who they're talking to and can help you through the process if your app gets rejected due to a guideline issue. Make sure to provide the correct invitation code so that you get associated with the organization. Using Canopie markup and JavaScript , you can create Mini Apps. Canopie comes pre-loaded with an SDK and Material UI style so that you don't need to build anything from scratch. Example Canopie Code CPML {{ items.map((item, idx) => cpml` < list-item id = 'item-{{idx}}' > < view class = 'content' > < text class = 'primary-content' > {{item.name}}, {{item.price}} </ text > </ view > </ list-item > `) }} JavaScript Page ({ data : { items : [ { name : 'Apple' , price : 1.50 }, { name : 'Durian' , price : 40.00 } ] } }); This example code loops through the items list and renders a <text> element for each item based on the template. On the JavaScript side, the data is pre-loaded for the Page that will be loaded for the Mini App. It pre-populates the items variable with a json structure. This terminology, examples of Canopie markup and JavaScript will be further explained in the next sections. On the Developer portal itself, you need to \"create\" the Mini App and fill in its details. You'll then get a link to Note: Canopie is currently in Alpha and not yet making these tools public. A Visual Studio Code plug-in is also coming soon.","title":"Registering and Creating Mini Apps (Steps 3 and 4)"},{"location":"#submitting-and-publishing-steps-5-to-8","text":"When you're done and happy with the Mini App. Hop onto the Developer Portal to see your builds. Submit one of those builds to get it reviewed. The reviewer in the organization will take a look, launch, test and read the description of your Mini App. They need to ensure that your Mini App follows their organization guidelines and that it provides good value to the end user. If everything is good, the reviewer accepts the submission and you then have the option of publishing it into production. The Mini Apps get deployed to a CDN and produce a QR code for users on the Super App to scan and launch.","title":"Submitting and Publishing (Steps 5 to 8)"},{"location":"canopie_markup_language/","text":"Canopie Markup Language Canopie Markup Language, or CPML ( *.cpml ), is an HTML-like DSL. It is mainly based on tags , with the capability of dynamic rendering with variables / expressions and assignment statements . Canopie supports a subset of HTML tags as well as a collection of pre-built components known as the Canopie Components. Canopie Components Canopie offers a library of UI components as building blocks for the mini app. It has built-in Material style, and can also be customised via CPSS. Attributes Each component has a list of attributes that it supports. These attributes can be set to dynamic values using the variables and expressions notation . Note that there are two types of special attributes: @event To add a handler for the specified event. < button @ tap = {{onTap}} /> ?boolean To add a boolean attribute. This is mostly used for dynamic values, as static boolean values can be set by simply including or omitting the attribute. Dynamic boolean value < button ? isDisabled = {{isDisabled}} /> Static true < button isDisabled /> Static false < button /> Currently Available Components See our Storybook for examples and detailed documentation. More to come... <view> The basic container for UI elements. < view > < button /> < text > some text </ text > </ view > <text> < text class = \"content\" > some text </ text > <text-input> < text-input id = 'text-input-id' label = 'Email' iconLeading = 'email' iconTrailing = 'clear' placeholder = 'your.name@example.com' type = 'email' helper = 'Please enter your email here.' ? isHelperPersistent = {{isHelperPersistent}} ? isRequired = {{isRequired}} ? isDisabled = {{isDisabled}} ? isOutlined = {{isOutlined}} @ change = {{onChange}} /> <button> < button id = 'button-id' label = 'Tap Me' icon = 'home' type = 'raised' @ tap = {{onTap}} ? isDisabled = {{isDisabled}} /> <icon-button> < icon-button id = 'icon-button-id' icon = 'home' label = 'home' @ tap = {{onTap}} /> <switch> < switch id = 'switch-id' @ tap = {{onTap}} /> <circular-progress> Determinate < circular-progress id = 'circular-progress-determinate' progress = 0.7 density = 10 /> Indeterminate < circular-progress id = 'circular-progress-indeterminate' density = 10 isIndeterminate ? isDone = {{isDone}} /> <dialog> < dialog id = 'item-redeem-dialog' heading = 'Confirm Your Choice' primaryLabel = 'OK' secondaryLabel = 'Cancel' @ primarytap = {{onRedeem}} @ secondarytap = {{onCancel}} @ close = {{onClose}} ? open = {{shouldShowDialog}} > < text > Are you sure to redeem points for this item? </ text > </ dialog > <list> and <list-item> < list id = 'activity-list' ? activatable = {{activatable}} @ select = {{onSelect}} > {{activities.map((activity, idx) => cpml` < list-item id = 'activity-list-item-{{idx}}' > < view class = 'content' > < text class = 'primary-content' > {{activity.content}} </ text > </ view > </ list-item > `}} </ list > <image-list> < image-list id = 'redeem-item-list' class = 'item-list' images = {{images}} columnsCount = 2 gutterSize = 10 imageFit = 'cover' imageBorderRadius = 0 icon = 'redeem' labelStyle = {{{ textTransform: ' capitalize ', }}} ? hasTextProtection = {{hasTextProtection}} @ icontap = {{onChoose}} @ imagetap = {{onImageTap}} /> Variables and Expressions CPML supports dynamic rendering with variables and expressions using the {{ }} notation. The variables need to be either defined in the data field of the Page object, or assigned a value in an assignment statement . Variables can be used either as a child of a tag or in attributes. Variable < text class = 'title' > {{title}} </ text > Expression < text > Price: {{item.price / 100.0}} </ text > Variable in attributes < switch id = 'switch-{{index}}' @ tap = {{onTap}} /> Nesting CPML elements can be nested inside {{ }} by using the cmpl`` notation. See the following sections for examples. Conditionals Conditional rendering can be achieved by either a ternary operator or a null coalescing operator. Ternary operator {{activity.hasStayAgain ? cpml` < view class = 'action' > < text > Stay Again </ text > </ view > ` : ''}} Null coalescing operator < text class = \"item-name\" > {{item.name ?? 'unknown'}} </ text > Loops Looping through a collection to render each element can be achieved by using the .map() function similar to that in JavaScript. {{activities.map((activity, idx) => cpml` < list-item id = 'activity-list-item-{{idx}}' > < view class = 'content' > < text class = 'primary-content' > {{activity.content}} </ text > </ view > </ list-item > `}} Assignment Statement Assignment statement are added into CPML using the {% %} notation. It mainly serves to declare and initialize new variables for (re)use on the page, to transform or compute certain values based on existing variables defined in the Page object. The right hand side of the assignment can either be an expression or some function call. It is recommended to put these statements at the top of the CPML file. The difference between {{ }} and {% %} is that, {{ }} should always return either a value or a CMPL element, whereas {% %} is purely used for declaring and initializing new variables without returning anything. Assignment by expression { % percentage = ( value - minValue ) / ( maxValue - minValue ) % } < text > Percentage : {{ percentage }} < /text> Assignment by function call { % images = items ? . map (({ image , name , price }) => { return { imageURL : image , label : `{{name}} {{price.toLocaleString()}}` , } }) % }","title":"Canopie Markup Language"},{"location":"canopie_markup_language/#canopie-markup-language","text":"Canopie Markup Language, or CPML ( *.cpml ), is an HTML-like DSL. It is mainly based on tags , with the capability of dynamic rendering with variables / expressions and assignment statements . Canopie supports a subset of HTML tags as well as a collection of pre-built components known as the Canopie Components.","title":"Canopie Markup Language"},{"location":"canopie_markup_language/#canopie-components","text":"Canopie offers a library of UI components as building blocks for the mini app. It has built-in Material style, and can also be customised via CPSS.","title":"Canopie Components"},{"location":"canopie_markup_language/#attributes","text":"Each component has a list of attributes that it supports. These attributes can be set to dynamic values using the variables and expressions notation . Note that there are two types of special attributes:","title":"Attributes"},{"location":"canopie_markup_language/#event","text":"To add a handler for the specified event. < button @ tap = {{onTap}} />","title":"@event"},{"location":"canopie_markup_language/#boolean","text":"To add a boolean attribute. This is mostly used for dynamic values, as static boolean values can be set by simply including or omitting the attribute. Dynamic boolean value < button ? isDisabled = {{isDisabled}} /> Static true < button isDisabled /> Static false < button />","title":"?boolean"},{"location":"canopie_markup_language/#currently-available-components","text":"See our Storybook for examples and detailed documentation. More to come...","title":"Currently Available Components"},{"location":"canopie_markup_language/#view","text":"The basic container for UI elements. < view > < button /> < text > some text </ text > </ view >","title":"&lt;view&gt;"},{"location":"canopie_markup_language/#text","text":"< text class = \"content\" > some text </ text >","title":"&lt;text&gt;"},{"location":"canopie_markup_language/#text-input","text":"< text-input id = 'text-input-id' label = 'Email' iconLeading = 'email' iconTrailing = 'clear' placeholder = 'your.name@example.com' type = 'email' helper = 'Please enter your email here.' ? isHelperPersistent = {{isHelperPersistent}} ? isRequired = {{isRequired}} ? isDisabled = {{isDisabled}} ? isOutlined = {{isOutlined}} @ change = {{onChange}} />","title":"&lt;text-input&gt;"},{"location":"canopie_markup_language/#button","text":"< button id = 'button-id' label = 'Tap Me' icon = 'home' type = 'raised' @ tap = {{onTap}} ? isDisabled = {{isDisabled}} />","title":"&lt;button&gt;"},{"location":"canopie_markup_language/#icon-button","text":"< icon-button id = 'icon-button-id' icon = 'home' label = 'home' @ tap = {{onTap}} />","title":"&lt;icon-button&gt;"},{"location":"canopie_markup_language/#switch","text":"< switch id = 'switch-id' @ tap = {{onTap}} />","title":"&lt;switch&gt;"},{"location":"canopie_markup_language/#circular-progress","text":"Determinate < circular-progress id = 'circular-progress-determinate' progress = 0.7 density = 10 /> Indeterminate < circular-progress id = 'circular-progress-indeterminate' density = 10 isIndeterminate ? isDone = {{isDone}} />","title":"&lt;circular-progress&gt;"},{"location":"canopie_markup_language/#dialog","text":"< dialog id = 'item-redeem-dialog' heading = 'Confirm Your Choice' primaryLabel = 'OK' secondaryLabel = 'Cancel' @ primarytap = {{onRedeem}} @ secondarytap = {{onCancel}} @ close = {{onClose}} ? open = {{shouldShowDialog}} > < text > Are you sure to redeem points for this item? </ text > </ dialog >","title":"&lt;dialog&gt;"},{"location":"canopie_markup_language/#list-and-list-item","text":"< list id = 'activity-list' ? activatable = {{activatable}} @ select = {{onSelect}} > {{activities.map((activity, idx) => cpml` < list-item id = 'activity-list-item-{{idx}}' > < view class = 'content' > < text class = 'primary-content' > {{activity.content}} </ text > </ view > </ list-item > `}} </ list >","title":"&lt;list&gt; and &lt;list-item&gt;"},{"location":"canopie_markup_language/#image-list","text":"< image-list id = 'redeem-item-list' class = 'item-list' images = {{images}} columnsCount = 2 gutterSize = 10 imageFit = 'cover' imageBorderRadius = 0 icon = 'redeem' labelStyle = {{{ textTransform: ' capitalize ', }}} ? hasTextProtection = {{hasTextProtection}} @ icontap = {{onChoose}} @ imagetap = {{onImageTap}} />","title":"&lt;image-list&gt;"},{"location":"canopie_markup_language/#variables-and-expressions","text":"CPML supports dynamic rendering with variables and expressions using the {{ }} notation. The variables need to be either defined in the data field of the Page object, or assigned a value in an assignment statement . Variables can be used either as a child of a tag or in attributes. Variable < text class = 'title' > {{title}} </ text > Expression < text > Price: {{item.price / 100.0}} </ text > Variable in attributes < switch id = 'switch-{{index}}' @ tap = {{onTap}} />","title":"Variables and Expressions"},{"location":"canopie_markup_language/#nesting","text":"CPML elements can be nested inside {{ }} by using the cmpl`` notation. See the following sections for examples.","title":"Nesting"},{"location":"canopie_markup_language/#conditionals","text":"Conditional rendering can be achieved by either a ternary operator or a null coalescing operator. Ternary operator {{activity.hasStayAgain ? cpml` < view class = 'action' > < text > Stay Again </ text > </ view > ` : ''}} Null coalescing operator < text class = \"item-name\" > {{item.name ?? 'unknown'}} </ text >","title":"Conditionals"},{"location":"canopie_markup_language/#loops","text":"Looping through a collection to render each element can be achieved by using the .map() function similar to that in JavaScript. {{activities.map((activity, idx) => cpml` < list-item id = 'activity-list-item-{{idx}}' > < view class = 'content' > < text class = 'primary-content' > {{activity.content}} </ text > </ view > </ list-item > `}}","title":"Loops"},{"location":"canopie_markup_language/#assignment-statement","text":"Assignment statement are added into CPML using the {% %} notation. It mainly serves to declare and initialize new variables for (re)use on the page, to transform or compute certain values based on existing variables defined in the Page object. The right hand side of the assignment can either be an expression or some function call. It is recommended to put these statements at the top of the CPML file. The difference between {{ }} and {% %} is that, {{ }} should always return either a value or a CMPL element, whereas {% %} is purely used for declaring and initializing new variables without returning anything. Assignment by expression { % percentage = ( value - minValue ) / ( maxValue - minValue ) % } < text > Percentage : {{ percentage }} < /text> Assignment by function call { % images = items ? . map (({ image , name , price }) => { return { imageURL : image , label : `{{name}} {{price.toLocaleString()}}` , } }) % }","title":"Assignment Statement"},{"location":"enterprise/","text":"Enterprise Tier The enterprise subscription allows your organization to deploy all components of Canopie on infrastructure you choose. This can be a combination of on prem, hybrid cloud, public cloud or one of the supported options below. Rebranding Canopie for your organization purposes is available at this tier. This means complete control over branding, marketing, scalability, security etc. fully available to your organization. Below is a description of some of the components available. Note: These are features that come out of the box with the Canopie platform. The backend is entirely REST API driven. Enterprise customers please contact sales@canopie.io for API documentation. Main Components All modules are built as container services and can be used to scale out horizontally. By using containers, it can be deployed onto many cloud services and be agnostic to a lot of environments. Some examples of environments that the modules could work in will include: RedHat's OpenShift Google Cloud GKE, App Engine AWS' Elastic Beanstalk, EKS, Lambda Azure Kubernetes Service (AKS) Alibaba Container Service for Kubernetes Custom Kubernetes Clusters Many more Developer Portal The portal is the entrypoint for in house developers or third party developers to register and submit Mini Apps on. This is identical to Canopie's SaaS offering on the free and non enterprise tiers. The portal is the first touch point for developers to register their interest in developing for your Super App. Developers register, create Mini Apps and submit them using the portal. Publishing also happens through this interface. Since this is the public facing side of the Canopie stack, your organization can rebrand it to how they see fit or even charge developers a registration fee. The Developer Developers can be individuals or companies that wish to build a Mini App on your platform. They could be internal to your organization as a different business unit or they could be external third parties if you wish to open up the Super App ecosystem to external developers. As a developer, the main tasks on the portal would be: Registering on the portal and paying any fee associated to be on the platform Creating Mini Apps Managing developers who should be part of the Mini App Submitting Mini Apps for review Resolving any issues with Mini App if rejected from the review Publishing the Mini App into production The Reviewer The reviewer is an employee of the organization. Their job is to look at Mini App submissions for the Super App. They need to test and review Mini Apps to ensure that it does not violate any of the terms of service or guidelines of the Super App. These guidelines need to be provided by the organization so that Developers adhere to them in the first place. This ensures that there is a consistent and good experience for end users. The Organization Admin The super user of the organization has complete control over the platform. The admin has all the powers of a Reviewer and can add new Reviewers to the organization. In addition, the admin manages billing, security, and native specific features for the Super App. Compiler Canopie comes with its own extensible DSL for developers to create Mini Apps on. Specifically it comes with an HTML-like DSL called CPML and a near identical JavaScript like DSL here . The JavaScript comes bundled with a handy SDK for common functionality and hooking into the Mini App lifecycle. It also provides some native callbacks to the host platform e.g. the Dialer, Camera etc. on the device. In addition, Canopie can bundle a custom SDK to give Mini Apps reusable functionality offered by the organization to give the Super App extended functionality. E.g. if the Super App had a payments service or special information around the user, it can be exposed through this custom SDK. Here is a snippet of what a Canopie Mini Program might look like for showing a list of merchandise for a fruit store: Tester App To support the developers when they write Mini Apps, the tester app is a mobile application that can scan developer build versions that are not yet exposed to the public. This will help developers during the development lifecycle of the Mini App. This tester app also protects the Mini App from external access with encrypted QR codes and artifacts that is meant specifically for the developers' eyes only. Additionally, this is particularly useful when bringing a custom SDK to extend the capabilities of the Super App and ensure that there are no clashes with variables, namespacing and other existing functionality. Finally the tester app will assist the reviewer teams when they need to review a Mini App. They can launch it and double check that it follows the guidelines of the platform. Mini App Hosting The Mini App hosting module will serve the verified Mini Apps worldwide on the chosen CDN provider. The module enables the platform to utilize its own domain name so that it's possible to serve MPs on something like https://mp.yourdomain.com/mp-name/version . Use of a CDN enables caching and fast serving to the end customers, no matter where they are in the world. All the benefits of a traditional CDN are true which will offload the resources necessary in the platform's data centre, assuming that the data centre isn't a CDN itself. What Canopie Doesn't Do Canopie services come in containers to have both flexibility in utilization and portability. They can be paired with other services in a Kubernetes based pod. Each organization, especially at the enterprise level, have different security, provisioning, networking, deployment processes and so forth. In the future, Canopie may provide these as optional plugins or configurations. Canopie will provide the means to mark Third Party Developers as verified but does not do the verification process itself. The organization will need to have a way to verify the identity of the registrants. Verifying developers is important to ensure accountability, billing, dispute resolution and protection of the platform's brand. Consulting and Support Enterprise customers enjoy the benefit of being first class citizens for support over other tiers. Custom SLAs can be tailored to your needs. Feel free to reach out to sales@canopie.io for a free consultation on whether Canopie is right for the organization. Canopie has consultants available to discuss and tackle how to best integrate Canopie based on the unique structure of every business.","title":"Enterprise Tier"},{"location":"enterprise/#enterprise-tier","text":"The enterprise subscription allows your organization to deploy all components of Canopie on infrastructure you choose. This can be a combination of on prem, hybrid cloud, public cloud or one of the supported options below. Rebranding Canopie for your organization purposes is available at this tier. This means complete control over branding, marketing, scalability, security etc. fully available to your organization. Below is a description of some of the components available. Note: These are features that come out of the box with the Canopie platform. The backend is entirely REST API driven. Enterprise customers please contact sales@canopie.io for API documentation.","title":"Enterprise Tier"},{"location":"enterprise/#main-components","text":"All modules are built as container services and can be used to scale out horizontally. By using containers, it can be deployed onto many cloud services and be agnostic to a lot of environments. Some examples of environments that the modules could work in will include: RedHat's OpenShift Google Cloud GKE, App Engine AWS' Elastic Beanstalk, EKS, Lambda Azure Kubernetes Service (AKS) Alibaba Container Service for Kubernetes Custom Kubernetes Clusters Many more","title":"Main Components"},{"location":"enterprise/#developer-portal","text":"The portal is the entrypoint for in house developers or third party developers to register and submit Mini Apps on. This is identical to Canopie's SaaS offering on the free and non enterprise tiers. The portal is the first touch point for developers to register their interest in developing for your Super App. Developers register, create Mini Apps and submit them using the portal. Publishing also happens through this interface. Since this is the public facing side of the Canopie stack, your organization can rebrand it to how they see fit or even charge developers a registration fee.","title":"Developer Portal"},{"location":"enterprise/#the-developer","text":"Developers can be individuals or companies that wish to build a Mini App on your platform. They could be internal to your organization as a different business unit or they could be external third parties if you wish to open up the Super App ecosystem to external developers. As a developer, the main tasks on the portal would be: Registering on the portal and paying any fee associated to be on the platform Creating Mini Apps Managing developers who should be part of the Mini App Submitting Mini Apps for review Resolving any issues with Mini App if rejected from the review Publishing the Mini App into production","title":"The Developer"},{"location":"enterprise/#the-reviewer","text":"The reviewer is an employee of the organization. Their job is to look at Mini App submissions for the Super App. They need to test and review Mini Apps to ensure that it does not violate any of the terms of service or guidelines of the Super App. These guidelines need to be provided by the organization so that Developers adhere to them in the first place. This ensures that there is a consistent and good experience for end users.","title":"The Reviewer"},{"location":"enterprise/#the-organization-admin","text":"The super user of the organization has complete control over the platform. The admin has all the powers of a Reviewer and can add new Reviewers to the organization. In addition, the admin manages billing, security, and native specific features for the Super App.","title":"The Organization Admin"},{"location":"enterprise/#compiler","text":"Canopie comes with its own extensible DSL for developers to create Mini Apps on. Specifically it comes with an HTML-like DSL called CPML and a near identical JavaScript like DSL here . The JavaScript comes bundled with a handy SDK for common functionality and hooking into the Mini App lifecycle. It also provides some native callbacks to the host platform e.g. the Dialer, Camera etc. on the device. In addition, Canopie can bundle a custom SDK to give Mini Apps reusable functionality offered by the organization to give the Super App extended functionality. E.g. if the Super App had a payments service or special information around the user, it can be exposed through this custom SDK. Here is a snippet of what a Canopie Mini Program might look like for showing a list of merchandise for a fruit store:","title":"Compiler"},{"location":"enterprise/#tester-app","text":"To support the developers when they write Mini Apps, the tester app is a mobile application that can scan developer build versions that are not yet exposed to the public. This will help developers during the development lifecycle of the Mini App. This tester app also protects the Mini App from external access with encrypted QR codes and artifacts that is meant specifically for the developers' eyes only. Additionally, this is particularly useful when bringing a custom SDK to extend the capabilities of the Super App and ensure that there are no clashes with variables, namespacing and other existing functionality. Finally the tester app will assist the reviewer teams when they need to review a Mini App. They can launch it and double check that it follows the guidelines of the platform.","title":"Tester App"},{"location":"enterprise/#mini-app-hosting","text":"The Mini App hosting module will serve the verified Mini Apps worldwide on the chosen CDN provider. The module enables the platform to utilize its own domain name so that it's possible to serve MPs on something like https://mp.yourdomain.com/mp-name/version . Use of a CDN enables caching and fast serving to the end customers, no matter where they are in the world. All the benefits of a traditional CDN are true which will offload the resources necessary in the platform's data centre, assuming that the data centre isn't a CDN itself.","title":"Mini App Hosting"},{"location":"enterprise/#what-canopie-doesnt-do","text":"Canopie services come in containers to have both flexibility in utilization and portability. They can be paired with other services in a Kubernetes based pod. Each organization, especially at the enterprise level, have different security, provisioning, networking, deployment processes and so forth. In the future, Canopie may provide these as optional plugins or configurations. Canopie will provide the means to mark Third Party Developers as verified but does not do the verification process itself. The organization will need to have a way to verify the identity of the registrants. Verifying developers is important to ensure accountability, billing, dispute resolution and protection of the platform's brand.","title":"What Canopie Doesn't Do"},{"location":"enterprise/#consulting-and-support","text":"Enterprise customers enjoy the benefit of being first class citizens for support over other tiers. Custom SLAs can be tailored to your needs. Feel free to reach out to sales@canopie.io for a free consultation on whether Canopie is right for the organization. Canopie has consultants available to discuss and tackle how to best integrate Canopie based on the unique structure of every business.","title":"Consulting and Support"},{"location":"javascript_sdk/","text":"Canopie JavaScript SDK The SDK is prefixed with cp which you can call in your *.js file. The purpose of the SDK is to give your Mini Apps additional functionality such as making network calls, saving data, and calling host functions. It's complimentary to the Canopie Markup Language (CPML) but does not replace it. Several uses for the SDK include: - hooking into the Mini App lifecycle - calling native host functions - making network requests - binding functions to user events like button presses - calling the Super App's user functions such as getting the user's details or asking the user to do payments on the Super App's platform Setting Data Generally at the end of the function, the visual components need to update their state somehow by seeing what data has changed. To save the data to the Mini App cache and to reflect the changes in the Mini App, the cp.setData method should be called. Once the function has run, internally, Canopie will save the current state of the data anyway. Ensure that what's being saved is up to date! The argument to cp.setData() is any object. Note : You can always access the current state of the data with cp.data . The data object in the Page() function below is what cp.data will set itself to in the initial state when the Mini App loads. cp.setData(object) Set Data in Page Func Page ({ data : { count : 0 , }, onButtonTap : ( e ) => { let { count } = cp . data count ++ cp . setData ({ count , }) } }) Network Request cp.request(options) GET cp . request ({ url : 'https://example.com/getMovies/rand' , headers : { 'content-type' : 'application/json' // Default value }, success : function ( res ) { console . log ( res . data ); cp . setData ({ movie : { title : res . data . title , description : res . data . desc } }) } }) POST cp . request ({ url : 'https://example.com/createMovie' , method : 'post' , data : { title : 'my movie' , description : 'my description' }, headers : { 'content-type' : 'application/json' , 'x-api-key' : 'xxx' }, failure : function ( res ) { console . log ( res . data . errorMessage ); } }) Parameters Property Description Type Required url Network resource of the call e.g. https://localhost:3000 String Y headers An object with a bunch of key value pairs. The values are the exact same as the HTTP standard. By default it is set to: {'content-type': 'application/json' // Default value} Object N method HTTP Method. By default it is get can be also be one of: head , post , delete , or patch String N data Optional javascript object used as post parameters Object N dataType The type of data being sent in the data parameter above. By default, it is set to json . Can also be text , arraybuffer , or stream String N success A function that takes a res object i.e. success(res) where res is whatever is returned by the network call. Upon a 2XX status code, this function will get run and perform work on the res. Function N failure Similar to success above, this will only run if it's a non 2XX status code Function N It's also important to note that the request function will throw an error if something really goes wrong. Ensure to wrap this in try and catch or risk the Mini App crashing. More to come","title":"Javascript SDK"},{"location":"javascript_sdk/#canopie-javascript-sdk","text":"The SDK is prefixed with cp which you can call in your *.js file. The purpose of the SDK is to give your Mini Apps additional functionality such as making network calls, saving data, and calling host functions. It's complimentary to the Canopie Markup Language (CPML) but does not replace it. Several uses for the SDK include: - hooking into the Mini App lifecycle - calling native host functions - making network requests - binding functions to user events like button presses - calling the Super App's user functions such as getting the user's details or asking the user to do payments on the Super App's platform","title":"Canopie JavaScript SDK"},{"location":"javascript_sdk/#setting-data","text":"Generally at the end of the function, the visual components need to update their state somehow by seeing what data has changed. To save the data to the Mini App cache and to reflect the changes in the Mini App, the cp.setData method should be called. Once the function has run, internally, Canopie will save the current state of the data anyway. Ensure that what's being saved is up to date! The argument to cp.setData() is any object. Note : You can always access the current state of the data with cp.data . The data object in the Page() function below is what cp.data will set itself to in the initial state when the Mini App loads. cp.setData(object) Set Data in Page Func Page ({ data : { count : 0 , }, onButtonTap : ( e ) => { let { count } = cp . data count ++ cp . setData ({ count , }) } })","title":"Setting Data"},{"location":"javascript_sdk/#network-request","text":"cp.request(options) GET cp . request ({ url : 'https://example.com/getMovies/rand' , headers : { 'content-type' : 'application/json' // Default value }, success : function ( res ) { console . log ( res . data ); cp . setData ({ movie : { title : res . data . title , description : res . data . desc } }) } }) POST cp . request ({ url : 'https://example.com/createMovie' , method : 'post' , data : { title : 'my movie' , description : 'my description' }, headers : { 'content-type' : 'application/json' , 'x-api-key' : 'xxx' }, failure : function ( res ) { console . log ( res . data . errorMessage ); } })","title":"Network Request"},{"location":"javascript_sdk/#parameters","text":"Property Description Type Required url Network resource of the call e.g. https://localhost:3000 String Y headers An object with a bunch of key value pairs. The values are the exact same as the HTTP standard. By default it is set to: {'content-type': 'application/json' // Default value} Object N method HTTP Method. By default it is get can be also be one of: head , post , delete , or patch String N data Optional javascript object used as post parameters Object N dataType The type of data being sent in the data parameter above. By default, it is set to json . Can also be text , arraybuffer , or stream String N success A function that takes a res object i.e. success(res) where res is whatever is returned by the network call. Upon a 2XX status code, this function will get run and perform work on the res. Function N failure Similar to success above, this will only run if it's a non 2XX status code Function N It's also important to note that the request function will throw an error if something really goes wrong. Ensure to wrap this in try and catch or risk the Mini App crashing.","title":"Parameters"},{"location":"javascript_sdk/#more-to-come","text":"","title":"More to come"},{"location":"mini_app_example/","text":"Mini App Examples Documentation WIP","title":"Mini App Example"},{"location":"mini_app_example/#mini-app-examples","text":"Documentation WIP","title":"Mini App Examples"},{"location":"review/","text":"Review Module Note: Documentation WIP The following endpoints allow third parties to manage their Mini App in a staging area and when everything is ready, to release it into production. Mini App Status Mini Programs can have one of a number of statuses depending on where it is in the review/release life cycle. In rough order they are: Pending Review : The Mini App has been submitted for review by the platform. It has not yet been assigned to a reviewer. In Review : A reviewer has been assigned and will get back to the developer with changes if necessary or change the status to approved. Review Cancelled : The developer has decided to cancel the review of the Mini App. The reviewer no longer needs to look at this version. Requires Changes : The reviewer found issues that don't conform to the platform's guidelines and the developer will need to re-submit again once changes have been made. The status will go back into Pending Review once the developer submits again. Approved : The reviewer has approved the Mini App with a semantic version vX.X.X Released : The developer has clicked the deploy button and the application should be released with the latest semantic version showing.","title":"Review Status"},{"location":"review/#review-module","text":"Note: Documentation WIP The following endpoints allow third parties to manage their Mini App in a staging area and when everything is ready, to release it into production.","title":"Review Module"},{"location":"review/#mini-app-status","text":"Mini Programs can have one of a number of statuses depending on where it is in the review/release life cycle. In rough order they are: Pending Review : The Mini App has been submitted for review by the platform. It has not yet been assigned to a reviewer. In Review : A reviewer has been assigned and will get back to the developer with changes if necessary or change the status to approved. Review Cancelled : The developer has decided to cancel the review of the Mini App. The reviewer no longer needs to look at this version. Requires Changes : The reviewer found issues that don't conform to the platform's guidelines and the developer will need to re-submit again once changes have been made. The status will go back into Pending Review once the developer submits again. Approved : The reviewer has approved the Mini App with a semantic version vX.X.X Released : The developer has clicked the deploy button and the application should be released with the latest semantic version showing.","title":"Mini App Status"}]}